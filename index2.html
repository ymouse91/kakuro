<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kakuro - Premium Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6C63FF;
            --primary-dark: #5348E5;
            --secondary: #FF6584;
            --success: #00BFA6;
            --warning: #FFB74D;
            --error: #FF5252;
            --dark: #1E1E2E;
            --light: #FAFAFA;
            --gray: #9CA3AF;
            --cell-size: 52px;
            --gap: 2px;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(108, 99, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 101, 132, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(0, 191, 166, 0.2) 0%, transparent 50%);
            animation: floating 20s ease-in-out infinite;
            pointer-events: none;
        }
        .wrap{ display:grid; gap:12px; align-items:start; justify-items: center; width: min(100vw - 20px, 480px) }
  
        @keyframes floating {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(-20px, -20px) rotate(1deg); }
            66% { transform: translate(20px, -10px) rotate(-1deg); }
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            padding: 40px;
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.12),
                0 10px 20px rgba(0, 0, 0, 0.08);
            max-width: 900px;
            width: 100%;
            position: relative;
            z-index: 1;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 10px;
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .subtitle {
            text-align: center;
            color: var(--gray);
            margin-bottom: 30px;
            font-size: 0.95rem;
        }

        /* Controls Section */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 20px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 200px;
        }

        label {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--dark);
            white-space: nowrap;
        }

        select, input[type="range"], input[type="text"], input[type="checkbox"] {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
        }

        select:hover, input:hover {
            border-color: var(--primary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(108, 99, 255, 0.15);
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(108, 99, 255, 0.1);
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            background: linear-gradient(to right, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 5px;
            border: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border: 3px solid var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .value-display {
            background: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-weight: 600;
            color: var(--primary);
            min-width: 50px;
            text-align: center;
        }

        /* Board */
        .board {
            display: grid;
            gap: var(--gap);
            background: linear-gradient(145deg, #2c3e50, #34495e);
            padding: 3px;
            border-radius: 20px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.15),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
            margin: 30px auto;
            width: fit-content;
            position: relative;
        }

        .board::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: linear-gradient(45deg, var(--primary), var(--secondary), var(--success));
            border-radius: 20px;
            z-index: -1;
            opacity: 0.6;
            animation: borderGlow 3s ease-in-out infinite;
        }

        @keyframes borderGlow {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.4rem;
            cursor: pointer;
            position: relative;
            border-radius: 10px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .cell.white:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 16px rgba(108, 99, 255, 0.3);
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            z-index: 10;
        }

        .cell.white:active {
            transform: translateY(0) scale(0.98);
        }

        .cell.selected {
            background: linear-gradient(145deg, var(--primary), var(--primary-dark));
            color: white;
            box-shadow: 
                0 0 0 3px rgba(108, 99, 255, 0.3),
                0 10px 20px rgba(108, 99, 255, 0.4);
            animation: selectedPulse 2s ease-in-out infinite;
            z-index: 20;
        }

        @keyframes selectedPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 
                    0 0 0 3px rgba(108, 99, 255, 0.3),
                    0 10px 20px rgba(108, 99, 255, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 
                    0 0 0 5px rgba(108, 99, 255, 0.2),
                    0 15px 30px rgba(108, 99, 255, 0.5);
            }
        }

        .cell.err {
            background: linear-gradient(145deg, #ffebee, #ffcdd2);
            color: var(--error);
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
            20%, 40%, 60%, 80% { transform: translateX(3px); }
        }

        .cell.ok {
            background: linear-gradient(145deg, #e8f5e9, #c8e6c9);
            color: var(--success);
            animation: success 0.6s ease-out;
        }

        @keyframes success {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .black {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            color: #ecf0f1;
            cursor: default;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .black::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, 
                transparent 48%, 
                rgba(255, 255, 255, 0.2) 49%, 
                rgba(255, 255, 255, 0.2) 51%, 
                transparent 52%
            );
            border-radius: 10px;
        }

        .clue {
            position: absolute;
            font-size: 0.75rem;
            font-weight: 800;
            color: #ecf0f1;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .clue.down {
            bottom: 4px;
            left: 6px;
        }

        .clue.across {
            top: 4px;
            right: 6px;
        }

        /* Number Pad */
        .number-pad-container {
            margin-top: 30px;
            text-align: center;
        }

        .pad {
            display: inline-grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            padding: 25px;
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .key {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border: 2px solid transparent;
            border-radius: 15px;
            font-weight: 800;
            font-size: 1.3rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 4px 6px rgba(0, 0, 0, 0.1),
                inset 0 1px 2px rgba(255, 255, 255, 0.9);
        }

        .key:hover {
            transform: translateY(-3px) scale(1.05);
            background: linear-gradient(145deg, var(--primary), var(--primary-dark));
            color: white;
            box-shadow: 0 10px 20px rgba(108, 99, 255, 0.3);
        }

        .key:active {
            transform: translateY(0) scale(0.95);
        }

        .key.special {
            background: linear-gradient(145deg, var(--error), #ff3838);
            color: white;
        }

        .key.help {
            background: linear-gradient(145deg, var(--warning), #ff9800);
            color: white;
        }

        /* Action Buttons */
        .actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 30px;
            background: linear-gradient(145deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            border-radius: 50px;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(108, 99, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(108, 99, 255, 0.4);
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.secondary {
            background: linear-gradient(145deg, var(--secondary), #ff4569);
        }

        .btn.success {
            background: linear-gradient(145deg, var(--success), #00a693);
        }

        /* Status Message */
        .status {
            text-align: center;
            padding: 15px;
            margin-top: 20px;
            border-radius: 15px;
            font-weight: 600;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            color: var(--dark);
            transition: all 0.3s ease;
			width: min(100vw - 20px, 480px);
        }

        .status.error {
            background: linear-gradient(145deg, #ffebee, #ffcdd2);
            color: var(--error);
            animation: statusShake 0.5s ease;
        }

        .status.success {
            background: linear-gradient(145deg, #e8f5e9, #c8e6c9);
            color: var(--success);
            animation: statusBounce 0.6s ease;
        }

        @keyframes statusShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        @keyframes statusBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            :root {
                --cell-size: 40px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 20px;
            }
            
            .key {
                width: 50px;
                height: 50px;
                font-size: 1.1rem;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
        }

        /* Loading animation */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
    </style>
</head>
<body>
  <div class="wrap">
    <div>
      <h1>Kakuro – Classic & Latin-first</h1>
      <div class="legend">
        Valitse <b>tapa</b> (Classic = oikea Kakuro; Latin-first = 9×9 permutaatio → rivit/sarakkeet summa 45). 
        Säädä <b>ruudukon koko</b>, <b>min/max juoksupituus</b>, <b>mustausten osuus</b> ja halutessasi <b>yksikäsitteisyys</b> Classic-tilassa.
      </div>
    </div>

    <div class="row">
      <label>Tapa:</label>
      <select id="mode" class="ctrl">
        <option value="classic">Classic</option>
        <option value="latin">45 rivi/sarake</option>
      </select>

      <label>Ruudukon koko:</label>
      <select id="size" class="ctrl">
        <option>8</option><option selected>10</option><option>12</option><option>14</option>
      </select>
	  </div>
      <div class="row">
      <label>Min run:</label>
      <input id="minRun" class="ctrl" type="range" min="2" max="6" value="2" />
      <span id="minRunVal" class="ctrl" style="padding:4px 8px;">2</span>

      <label>Max run:</label>
      <input id="maxRun" class="ctrl" type="range" min="3" max="9" value="6" />
      <span id="maxRunVal" class="ctrl" style="padding:4px 8px;">6</span>
    </div>

    <div class="row">
      <label>Mustien osuus sisäruuduista (%):</label>
      <input id="pct" class="ctrl" type="range" min="10" max="50" value="30" />
      <span id="pctVal" class="ctrl" style="padding:4px 8px;">30%</span>

      <label>Siemen:</label>
      <input id="seed" class="ctrl" type="text" placeholder="opt." />

      <label style="margin-left:8px;">
        <input type="checkbox" id="unique" />
        Vaadi yksikäsitteinen (Classic)
      </label>
	  </div>


    <div class="note" id="latinNote" style="display:none;">
      Latin-first toimii vain kun sisäalue on 9×9 → valitse ruudukon koko 10×10.
    </div>

    <div class="board" id="board" aria-label="Kakuro-ruudukko"></div>

    <div class="row">
      <div class="pad" id="pad" aria-label="Numeronäppäimistö"></div>
      <span class="status" id="status">Valitse ruutu aloittaaksesi.</span>
    </div>
	      <div class="row">
            <button class="btn" id="resetBtn">Tyhjennä</button>
            <button class="btn" id="checkBtn">Tarkista</button>
	        <button class="btn" id="showBtn">Ratkaisu</button>
	        <button class="btn" id="newBtn">Uusi</button>
      </div>
  </div>

<script>
/* ======================= ASETUKSET ======================= */
let N = 10; // kokonaiskoko (sis. kehyksen)
let MIN_RUN = 2;
let MAX_RUN = 6;
const MAX_NODE_VISITS = 120000;  // classic-solver
const MAX_MASK_TRIES = 400;
const UNIQUE_NODE_CAP = 250000;  // uniqueness-solverin varoraja
/* ========================================================= */

const boardEl = document.getElementById('board');
const padEl = document.getElementById('pad');
const statusEl = document.getElementById('status');
const newBtn = document.getElementById('newBtn');
const showBtn = document.getElementById('showBtn');
const checkBtn = document.getElementById('checkBtn');
const resetBtn = document.getElementById('resetBtn');
const modeSel = document.getElementById('mode');
const sizeSel = document.getElementById('size');
const minRun = document.getElementById('minRun');
const maxRun = document.getElementById('maxRun');
const minRunVal = document.getElementById('minRunVal');
const maxRunVal = document.getElementById('maxRunVal');
const pct = document.getElementById('pct');
const pctVal = document.getElementById('pctVal');
const seedInput = document.getElementById('seed');
const latinNote = document.getElementById('latinNote');
const uniqueChk = document.getElementById('unique');

minRun.addEventListener('input', ()=>{ 
  MIN_RUN = parseInt(minRun.value,10); 
  if (MAX_RUN < MIN_RUN+1){ MAX_RUN = MIN_RUN+1; maxRun.value = String(MAX_RUN); }
  minRunVal.textContent = String(MIN_RUN);
  maxRunVal.textContent = String(MAX_RUN);
});
maxRun.addEventListener('input', ()=>{ 
  MAX_RUN = parseInt(maxRun.value,10); 
  if (MAX_RUN < MIN_RUN+1){ MIN_RUN = Math.max(2, MAX_RUN-1); minRun.value = String(MIN_RUN); }
  minRunVal.textContent = String(MIN_RUN);
  maxRunVal.textContent = String(MAX_RUN);
});
pct.addEventListener('input', ()=>{ pctVal.textContent = pct.value + '%'; });

sizeSel.addEventListener('change', ()=>{
  N = parseInt(sizeSel.value,10);
  updateLatinAvailability();
});
modeSel.addEventListener('change', updateLatinAvailability);

function updateLatinAvailability(){
  const inner = N-1;
  const latinAllowed = (inner === 9);
  latinNote.style.display = (modeSel.value==='latin' && !latinAllowed) ? 'block' : 'none';
  if(!latinAllowed && modeSel.value==='latin'){
    modeSel.value = 'classic';
  }
}

let MASK=null, SOL=null, CLUES=null, values=null, selected=null;

/* ---------- Siemennetty satunnaisuus (mulberry32) ---------- */
function mulberry32(a) {
  return function() {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
function seededRandomSetup(seedStr){
  if(!seedStr) return; // käytä normaalia Math.randomia
  let h=0;
  for(let i=0;i<seedStr.length;i++) h = Math.imul(31, h) + seedStr.charCodeAt(i) | 0;
  const rng = mulberry32(h>>>0);
  Math.random = rng; // huom! override tämän istunnon ajaksi
}

/* ---------- Apurit ---------- */
const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const shuffle=(arr)=>{for(let i=arr.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;};
const DIRS=[[1,0],[-1,0],[0,1],[0,-1]];
const inB=(r,c)=>r>=0&&r<N&&c>=0&&c<N;

function whiteConnectedSize(mask){
  const whites=[]; for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(mask[r][c]===1) whites.push([r,c]);
  if(!whites.length) return 0;
  const seen=Array.from({length:N},()=>Array(N).fill(false));
  const q=[whites[0]]; seen[whites[0][0]][whites[0][1]]=true;
  let cnt=0;
  while(q.length){
    const [r,c]=q.shift(); cnt++;
    for(const [dr,dc] of DIRS){
      const nr=r+dr,nc=c+dc;
      if(inB(nr,nc)&&!seen[nr][nc]&&mask[nr][nc]===1){ seen[nr][nc]=true; q.push([nr,nc]); }
    }
  }
  return cnt;
}
const countWhites = mask => mask.flat().filter(x=>x===1).length;

/* ---------- Rivit/juoksut ---------- */
function listRuns(mask) {
  const runs = { across: [], down: [] };
  // across
  for (let r = 0; r < N; r++) {
    let s = 0;
    while (s < N) {
      while (s < N && mask[r][s] === 0) s++;
      if (s >= N) break;
      let e = s;
      while (e + 1 < N && mask[r][e + 1] === 1) e++;
      runs.across.push({ r, s, e, len: e - s + 1 });
      s = e + 1;
    }
  }
  // down
  for (let c = 0; c < N; c++) {
    let s = 0;
    while (s < N) {
      while (s < N && mask[s][c] === 0) s++;
      if (s >= N) break;
      let e = s;
      while (e + 1 < N && mask[e + 1][c] === 1) e++;
      runs.down.push({ c, s, e, len: e - s + 1 });
      s = e + 1;
    }
  }
  return runs;
}
// aiheutuuko mustauksesta 1-ruudun juoksua?
function createsOneRun(mask, r, c) {
  // across
  let L = c - 1; while (L >= 0 && mask[r][L] === 1) L--;
  let R = c + 1; while (R < N && mask[r][R] === 1) R++;
  const leftLen  = c - 1 - L;
  const rightLen = R - (c + 1);
  if ((leftLen === 1 && mask[r][c - 1] === 1) || (rightLen === 1 && mask[r][c + 1] === 1)) return true;
  // down
  let U = r - 1; while (U >= 0 && mask[U][c] === 1) U--;
  let D = r + 1; while (D < N && mask[D][c] === 1) D++;
  const upLen   = r - 1 - U;
  const downLen = D - (r + 1);
  if ((upLen === 1 && mask[r - 1][c] === 1) || (downLen === 1 && mask[r + 1][c] === 1)) return true;
  return false;
}
// yritä leikata liian pitkä run järkevästi (ei 1-paloja, ei hajoa)
function tryCut(mask, r, c){
  const prevWhites = countWhites(mask);
  const old = mask[r][c];
  mask[r][c] = 0;
  const ok = !createsOneRun(mask, r, c) && whiteConnectedSize(mask) === prevWhites - 1;
  if(!ok) mask[r][c] = old;
  return ok;
}
function capLongRuns(mask) {
  let changed = true, safety = 0;
  while (changed && safety++ < 200) {
    changed = false;
    // across
    const runsA = listRuns(mask).across;
    for (const run of runsA) {
      if (run.len <= MAX_RUN) continue;
      const candidates = [];
      for(let pos=run.s+MIN_RUN; pos<=run.e-MIN_RUN; pos++) candidates.push(pos);
      shuffle(candidates);
      let cutMade=false;
      for(const pos of candidates){
        if(tryCut(mask, run.r, pos)){ cutMade=true; changed=true; break; }
      }
      if(cutMade) break;
    }
    if(changed) continue;
    // down
    const runsD = listRuns(mask).down;
    for (const run of runsD) {
      if (run.len <= MAX_RUN) continue;
      const candidates = [];
      for(let pos=run.s+MIN_RUN; pos<=run.e-MIN_RUN; pos++) candidates.push(pos);
      shuffle(candidates);
      let cutMade=false;
      for(const pos of candidates){
        if(tryCut(mask, pos, run.c)){ cutMade=true; changed=true; break; }
      }
      if(cutMade) break;
    }
  }
}

/* ---------- Latin-first ratkaisuruudukko (vain sisäalue 9×9) ---------- */
function latinSolution(){
  // sisäalueen koko oltava 9
  const grid = Array.from({length:N},()=>Array(N).fill(0));
  const perm = a => shuffle(a.slice());
  const rowP = perm([...Array(9)].map((_,i)=>i));
  const colP = perm([...Array(9)].map((_,i)=>i));
  const valP = perm([1,2,3,4,5,6,7,8,9]);
  for(let rr=0; rr<9; rr++){
    for(let cc=0; cc<9; cc++){
      const base = 1 + ((rr + cc) % 9);
      const v = valP[base-1];
      const r = rowP[rr] + 1;
      const c = colP[cc] + 1;
      grid[r][c] = v;
    }
  }
  return grid;
}

/* ---------- Classic: backtracking-täyttö (dupl. kielletty juoksuissa) ---- */
function getAcrossRun(mask,r,c){
  if(mask[r][c]===0) return [];
  let s=c; while(s>0 && mask[r][s-1]===1) s--;
  let e=c; while(e+1<N && mask[r][e+1]===1) e++;
  const out=[]; for(let x=s;x<=e;x++) out.push([r,x]); return out;
}
function getDownRun(mask,r,c){
  if(mask[r][c]===0) return [];
  let s=r; while(s>0 && mask[s-1][c]===1) s--;
  let e=r; while(e+1<N && mask[e+1][c]===1) e++;
  const out=[]; for(let y=s;y<=e;y++) out.push([y,c]); return out;
}
function fillSolutionClassic(mask){
  const whites=[]; for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(mask[r][c]===1) whites.push([r,c]);
  const acrossMap=new Map(), downMap=new Map();
  for(const [r,c] of whites){
    acrossMap.set(r+","+c, getAcrossRun(mask,r,c));
    downMap.set(r+","+c, getDownRun(mask,r,c));
  }
  const sol=Array.from({length:N},()=>Array(N).fill(0));
  let nodeVisits=0;
  function candAt(r,c){
    const a=acrossMap.get(r+","+c), d=downMap.get(r+","+c);
    const usedA=new Set(a.map(([rr,cc])=>sol[rr][cc]).filter(v=>v>0));
    const usedD=new Set(d.map(([rr,cc])=>sol[rr][cc]).filter(v=>v>0));
    const order = Math.random()<0.5 ? [...Array(9)].map((_,i)=>i+1) : shuffle([...Array(9)].map((_,i)=>i+1));
    const out=[]; for(const v of order){ if(!usedA.has(v)&&!usedD.has(v)) out.push(v); }
    return out;
  }
  function nextCell(){
    let best=null, score=1e9;
    for(const [r,c] of whites){
      if(sol[r][c]!==0) continue;
      const aLen=acrossMap.get(r+","+c).length;
      const dLen=downMap.get(r+","+c).length;
      const cands=candAt(r,c);
      if(cands.length===0) return [r,c,cands];
      const s=cands.length*10+(aLen+dLen);
      if(s<score){ score=s; best=[r,c,cands]; if(cands.length===1) break; }
    }
    return best;
  }
  function backtrack(){
    if(++nodeVisits>MAX_NODE_VISITS) return false;
    const pick=nextCell();
    if(!pick) return true;
    const [r,c,cands]=pick;
    for(const v of cands){
      sol[r][c]=v;
      if(backtrack()) return true;
      sol[r][c]=0;
      if(nodeVisits>MAX_NODE_VISITS) return false;
    }
    return false;
  }
  if(!backtrack()) return null;
  return sol;
}

/* ---------- Vihjeet ---------- */
function computeClues(mask, sol){
  const clues=Array.from({length:N},()=>Array(N).fill(null));
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      if(mask[r][c]===0){
        let A=null,D=null;
        if(c+1<N && mask[r][c+1]===1){
          let s=0,cc=c+1; while(cc<N && mask[r][cc]===1){ s+=sol[r][cc]; cc++; }
          if(cc>c+1) A=s;
        }
        if(r+1<N && mask[r+1][c] === 1){
          let s=0,rr=r+1; while(rr<N && mask[rr][c]===1){ s+=sol[rr][c]; rr++; }
          if(rr>r+1) D=s;
        }
        if(A!==null || D!==null) clues[r][c]={A,D};
      }
    }
  }
  return clues;
}

/* ---------- Maskin generointi (ensin valkoinen sisus, sitten mustataan) ---- */
function makeMaskAttempt(targetTotal){
  const m = Array.from({length:N},(_,r)=>Array.from({length:N},(_,c)=>(r===0||c===0)?0:1));
  let blacks = 2*N - 1;
  const inner=[]; for(let r=1;r<N;r++) for(let c=1;c<N;c++) inner.push([r,c]);
  shuffle(inner);
  for(const [r,c] of inner){
    if(blacks>=targetTotal) break;
    if(m[r][c]===0) continue;
    const prevWhites = countWhites(m);
    m[r][c]=0;
    if (createsOneRun(m, r, c) || whiteConnectedSize(m)!==prevWhites-1){
      m[r][c]=1;
    }else{
      blacks++;
    }
  }
  capLongRuns(m);
  return m;
}
function generateMaskByPct(pctInner){
  const base = 2*N - 1;
  const innerCells = (N-1)*(N-1);
  const add = Math.round(innerCells * (pctInner/100));
  const targetTotal = Math.min(base + add, N*N-1);
  for(let tries=0; tries<MAX_MASK_TRIES; tries++){
    const m = makeMaskAttempt(targetTotal);
    const runs = listRuns(m);
    const allOk = runs.across.every(r=>r.len>=MIN_RUN && r.len<=MAX_RUN)
                && runs.down.every(r=>r.len>=MIN_RUN && r.len<=MAX_RUN);
    const whites = countWhites(m);
    if(allOk && whiteConnectedSize(m)===whites) return m;
  }
  return makeMaskAttempt(targetTotal);
}

/* ---------- Uniqueness solver (mask + clues → laskee ratkaisujen määrää) ---- */
function buildRunsFromClues(mask, clues){
  const whites=[];
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(mask[r][c]===1) whites.push([r,c]);
  const aRuns=[], dRuns=[];
  const aIndex = Array.from({length:N},()=>Array(N).fill(-1));
  const dIndex = Array.from({length:N},()=>Array(N).fill(-1));
  // across runs from clues
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      if(mask[r][c]===0 && clues[r][c] && clues[r][c].A!=null){
        const sum = clues[r][c].A;
        const cells=[];
        let cc=c+1;
        while(cc<N && mask[r][cc]===1){ cells.push([r,cc]); cc++; }
        const idx=aRuns.length;
        aRuns.push({sum, cells});
        for(const [rr,cc2] of cells) aIndex[rr][cc2]=idx;
      }
    }
  }
  // down runs from clues
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      if(mask[r][c]===0 && clues[r][c] && clues[r][c].D!=null){
        const sum = clues[r][c].D;
        const cells=[];
        let rr=r+1;
        while(rr<N && mask[rr][c]===1){ cells.push([rr,c]); rr++; }
        const idx=dRuns.length;
        dRuns.push({sum, cells});
        for(const [rr2,cc] of cells) dIndex[rr2][cc]=idx;
      }
    }
  }
  return {whites, aRuns, dRuns, aIndex, dIndex};
}
function countSolutions(mask, clues, limit=2){
  const {whites, aRuns, dRuns, aIndex, dIndex} = buildRunsFromClues(mask, clues);
  const W = whites.length;
  const posIndex = new Map(); whites.forEach((p,i)=>posIndex.set(p[0]+","+p[1], i));

  // run states
  const aUsed = aRuns.map(()=>0);   // bitmask of used digits
  const dUsed = dRuns.map(()=>0);
  const aSum = aRuns.map(()=>0);
  const dSum = dRuns.map(()=>0);
  const aRem = aRuns.map((_,i)=>aRuns[i].cells.length);
  const dRem = dRuns.map((_,i)=>dRuns[i].cells.length);

  const assign = Array(W).fill(0);

  // helper: min/max possible sums from k smallest/largest available digits in set bits maskAvail (1..9 -> bits 1<<d)
  function minMaxPossible(maskAvail, k){
    const avail=[];
    for(let d=1; d<=9; d++) if(!(maskAvail & (1<<d))) avail.push(d); // maskAvail means "used" here
    if(avail.length < k) return [Infinity, -Infinity];
    avail.sort((a,b)=>a-b);
    let mn=0; for(let i=0;i<k;i++) mn+=avail[i];
    let mx=0; for(let i=0;i<k;i++) mx+=avail[avail.length-1-i];
    return [mn, mx];
  }

  function candidatesForCell(r,c){
    const ai = aIndex[r][c]; const di = dIndex[r][c];
    const usedA = aUsed[ai], usedD = dUsed[di];
    const sumA = aSum[ai], sumD = dSum[di];
    const remA = aRem[ai], remD = dRem[di];
    const targetA = aRuns[ai].sum, targetD = dRuns[di].sum;
    const out=[];
    for(let v=1; v<=9; v++){
      const bit = 1<<v;
      if(usedA & bit) continue;
      if(usedD & bit) continue;
      // after placing v
      const newSumA = sumA + v, newRemA = remA - 1, needA = targetA - newSumA;
      const newSumD = sumD + v, newRemD = remD - 1, needD = targetD - newSumD;
      if(needA < 0 || needD < 0) continue;
      // bounds for remaining
      const [minA,maxA] = minMaxPossible(usedA | bit, newRemA);
      const [minD,maxD] = minMaxPossible(usedD | bit, newRemD);
      if(newRemA>0 && (needA < minA || needA > maxA)) continue;
      if(newRemD>0 && (needD < minD || needD > maxD)) continue;
      if(newRemA===0 && needA!==0) continue;
      if(newRemD===0 && needD!==0) continue;
      out.push(v);
    }
    return out;
  }

  function pickCell(){
    let bestIdx=-1, bestCands=null, bestLen=1e9;
    for(let i=0;i<W;i++){
      if(assign[i]!==0) continue;
      const [r,c]=whites[i];
      const cands=candidatesForCell(r,c);
      const len=cands.length;
      if(len===0) return [i, cands];
      if(len<bestLen){ bestLen=len; bestIdx=i; bestCands=cands; if(len===1) break; }
    }
    return [bestIdx, bestCands];
  }

  let node=0, solutions=0;
  function dfs(){
    if(solutions>=limit) return; // early stop
    if(++node>UNIQUE_NODE_CAP) return; // give up
    // done?
    let done=true;
    for(let i=0;i<W;i++){ if(assign[i]===0){ done=false; break; } }
    if(done){ solutions++; return; }

    const [i, cands] = pickCell();
    if(i<0) return;
    const [r,c] = whites[i];
    const ai = aIndex[r][c], di = dIndex[r][c];
    for(const v of cands){
      const bit=1<<v;
      // place
      assign[i]=v;
      aUsed[ai]|=bit; aSum[ai]+=v; aRem[ai]--;
      dUsed[di]|=bit; dSum[di]+=v; dRem[di]--;
      dfs();
      // undo
      dRem[di]++; dSum[di]-=v; dUsed[di]&=~bit;
      aRem[ai]++; aSum[ai]-=v; aUsed[ai]&=~bit;
      assign[i]=0;
      if(solutions>=limit || node>UNIQUE_NODE_CAP) return;
    }
  }
  dfs();
  return {count: solutions, capped: (node>UNIQUE_NODE_CAP)};
}

/* ---------- UI ---------- */
function setBoardGrid(){
  const track = `repeat(${N}, var(--cell-size))`;
  boardEl.style.gridTemplateColumns = track;
  boardEl.style.gridTemplateRows = track;
}

function buildBoard(){
  setBoardGrid();
  boardEl.innerHTML="";
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const div=document.createElement('div');
      if(MASK[r][c]===0){
        div.className='cell black';
        const clue=CLUES[r][c];
        if(clue){
          if(clue.A!=null){ const d=document.createElement('div'); d.className='clue across'; d.textContent=clue.A; div.appendChild(d); }
          if(clue.D!=null){ const d=document.createElement('div'); d.className='clue down'; d.textContent=clue.D; div.appendChild(d); }
        }
      }else{
        div.className='cell white';
        div.dataset.r=r; div.dataset.c=c;
        div.addEventListener('click', ()=>selectCell(r,c));
        div.textContent=values[r][c];
      }
      boardEl.appendChild(div);
    }
  }
}
function refreshCells(){
  const kids=[...boardEl.children];
  for(let i=0;i<kids.length;i++){
    const r=(i/ N)|0, c=i%N;
    const el=kids[i];
    if(MASK[r][c]===1){
      el.textContent=values[r][c];
      el.classList.toggle('selected', !!selected && selected[0]===r && selected[1]===c);
      const st=checkCell(r,c);
      el.classList.toggle('err', st==='err');
      el.classList.toggle('ok',  st==='ok');
    }
  }
}
function selectCell(r,c){
  selected=[r,c];
  statusEl.textContent=`Valittu ruutu: rivi ${r+1}, sarake ${c+1}`;
  refreshCells();
}
const KEYS=['1','2','3','4','5','6','7','8','9','x','?'];
function buildPad(){
  padEl.innerHTML="";
  for(const k of KEYS){
    const b=document.createElement('button');
    b.className='key';
    if(k==='x') b.classList.add('special');
    if(k==='?') b.classList.add('help');
    b.textContent=k;
    b.addEventListener('click', ()=>pressKey(k));
    padEl.appendChild(b);
  }
}
function pressKey(k){
  if(!selected){ statusEl.textContent='Valitse ensin ruutu.'; return; }
  const [r,c]=selected;
  if(MASK[r][c]===0){ statusEl.textContent='Valitse valkoinen ruutu.'; return; }
  if(k==='x'){ values[r][c]=""; }
  else if(k==='?'){ values[r][c]=String(SOL[r][c]); }
  else { values[r][c]=k; }
  refreshCells();
}
function checkCell(r,c){
  if(MASK[r][c]===0) return null;
  const v=values[r][c]; if(!v) return null;

  const aRun=getAcrossRun(MASK,r,c);
  let left=aRun[0][1]-1;
  let A=(left>=0 && CLUES[r][left]) ? CLUES[r][left].A : null;
  const aVals=aRun.map(([rr,cc])=>values[rr][cc]).filter(x=>x!=="").map(Number);
  const aDup=(new Set(aVals)).size!==aVals.length;
  const aSum=aVals.reduce((a,b)=>a+b,0);
  if(aDup || (A!==null && aSum>A)) return 'err';
  if(A!==null && aVals.length===aRun.length && aSum===A){
    const allMatch=aRun.every(([rr,cc])=>String(SOL[rr][cc])===values[rr][cc]);
    if(allMatch) return 'ok';
  }

  const dRun=getDownRun(MASK,r,c);
  let up=dRun[0][0]-1;
  let D=(up>=0 && CLUES[up][c]) ? CLUES[up][c].D : null;
  const dVals=dRun.map(([rr,cc])=>values[rr][cc]).filter(x=>x!=="").map(Number);
  const dDup=(new Set(dVals)).size!==dVals.length;
  const dSum=dVals.reduce((a,b)=>a+b,0);
  if(dDup || (D!==null && dSum>D)) return 'err';
  if(D!==null && dVals.length===dRun.length && dSum===D){
    const allMatch=dRun.every(([rr,cc])=>String(SOL[rr][cc])===values[rr][cc]);
    if(allMatch) return 'ok';
  }
  return null;
}

/* ---------- Komennot ---------- */
checkBtn.addEventListener('click', ()=>{
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    if(MASK[r][c]===1){
      if(String(SOL[r][c])!==values[r][c]){
        statusEl.textContent='Ei vielä oikein. Vihje: ? paljastaa valitun ruudun.';
        refreshCells(); return;
      }
    }
  }
  statusEl.textContent='Täysin oikein! ✅';
  refreshCells();
});
resetBtn.addEventListener('click', ()=>{
  values=Array.from({length:N},()=>Array(N).fill(""));
  selected=null;
  statusEl.textContent='Kaikki merkinnät tyhjennetty.';
  refreshCells();
});
newBtn.addEventListener('click', ()=>newPuzzle());
showBtn.addEventListener('click', ()=>{
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    if(MASK[r][c]===1) values[r][c]=String(SOL[r][c]);
  }
  statusEl.textContent='Ratkaisu näytetty.';
  refreshCells();
});

/* ---------- Uuden pulman teko ---------- */
function newPuzzle(){
  // siemen
  seededRandomSetup(seedInput.value.trim());

  // asetukset
  N = parseInt(sizeSel.value,10);
  MIN_RUN = parseInt(minRun.value,10);
  MAX_RUN = parseInt(maxRun.value,10);
  if(MAX_RUN < MIN_RUN+1){ MAX_RUN = MIN_RUN+1; maxRun.value = String(MAX_RUN); }
  updateLatinAvailability();
  setBoardGrid();

  statusEl.textContent='Luodaan uutta ruudukkoa…';

  // 1) Ratkaisuruudukko
  if(modeSel.value==='latin'){
    // vain kun sisäalue on 9x9
    if(N!==10){ modeSel.value='classic'; }
  }
  if(modeSel.value==='latin'){
    SOL = latinSolution(); // 9x9 sisus
  }

  // 2) Maski
  MASK = generateMaskByPct(parseInt(pct.value,10));

  // 3) Classic: täytä ratkaisu maskin päälle, laske vihjeet
  let attempts = 0;
  if(modeSel.value==='classic'){
    while(true){
      SOL = fillSolutionClassic(MASK);
      if(!SOL){
        if(++attempts>8){
          MASK = generateMaskByPct(parseInt(pct.value,10));
          attempts=0;
        }else{
          continue;
        }
      }else{
        CLUES = computeClues(MASK, SOL);
        if(uniqueChk.checked){
          const res = countSolutions(MASK, CLUES, 2);
          if(res.capped){
            statusEl.textContent='Uniikkitarkistus keskeytettiin (liian raskas). Luo uudelleen tai löysää asetuksia.';
            break;
          }
          if(res.count===1){
            // ok, unique
            break;
          }else{
            // ei yksikäsitteinen → kokeile uusi ratkaisu tai uusi maski
            if(++attempts>10){
              MASK = generateMaskByPct(parseInt(pct.value,10));
              attempts=0;
            }
            // nollaa ja yritä taas
            SOL = null;
            continue;
          }
        }else{
          break;
        }
      }
    }
  } else {
    // Latin-first: vihjeet suoraan ratkaisusta
    CLUES = computeClues(MASK, SOL);
  }

  // 4) Pelaajalle tyhjä taulu
  values = Array.from({length:N},()=>Array(N).fill(""));
  selected=null;
  buildBoard();
  refreshCells();
  statusEl.textContent='Uusi ruudukko valmis. Valitse ruutu ja syötä numero.';
}

/* ---------- Alustus ---------- */
(function init(){
  buildPad();
  setBoardGrid();
  updateLatinAvailability();
  newPuzzle();
})();
</script>
</body>
</html>
