<!doctype html>
<html lang="fi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />


  <!-- Perustiedot -->
  <title>Kakuro</title>
  <meta name="description" content="Kakuro peli - logiikkapähkinä verkossa.">

  <!-- PWA manifest -->
  <link rel="manifest" href="manifest.json">

  <!-- PWA värit -->
  <meta name="theme-color" content="#0F172A">


  <!-- iOS-tuki (Apple) -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Kakuro">
  <link rel="apple-touch-icon" href="pwa_icon_180.png">

  <!-- Android & yleiset faviconit -->

  <link rel="icon" type="image/png" sizes="192x192" href="pwa_icon_192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="pwa_icon_512.png">



<style>
  :root{
    --cell: 46px;
    --gap: 2px;
    --bg: #f6f6f8;
    --black: #20232a;
    --ink: #111;
    --hint: #666;
    --bad: #e53935;
    --ok: #2e7d32;
    --accent: #0d6efd;

    --keyW: 56px;
    --keyH: 56px;
    --padGap: 8px;
  }
  *{ box-sizing: border-box }
  body{
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
    background: var(--bg); margin: 0; padding: 18px; color: var(--ink);
    display: grid; gap: 14px; place-items: start center;
	            background: 
                radial-gradient(circle at 20% 50%, rgba(108, 99, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 101, 132, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(0, 191, 166, 0.2) 0%, transparent 50%);
  }

  h1{ margin:0 0 4px; font-size:22px }
  .wrap{ display:grid; gap:12px; align-items:start; width: min(100vw - 20px, 480px) }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }

/* Ruudukko skaalautuu sisällön mukaan (ei veny 100% leveäksi) */
.board {
  display: inline-grid;        /* shrink-wrapaa sisällön */
  width: max-content;          /* tai fit-content, mutta max-content on varma */
  margin: 30px auto;
  gap: var(--gap);

  /* tausta, pyöristykset yms. – pidä omasi tai käytä näitä */
  position: relative;
  padding: calc(var(--gap) + 2px);
  border-radius: 16px;
  background:
    radial-gradient(120% 120% at 20% 0%,
      rgba(255,255,255,0.28) 0%,
      rgba(255,255,255,0) 40%),
    linear-gradient(145deg, #2c3e50, #34495e);
  box-shadow: 0 6px 18px rgba(0,0,0,.12);
  user-select: none;
}

/* Estä vanhemman flex/grid-venytys */
.board {
  align-self: center;   /* jos parentti on flex/grid joka venyttää */
  justify-self: center; /* jos parentti on CSS Grid */
}

/* (Valinnainen) hehkuva gradienttikehys */
.board::before{
  content: "";
  position: absolute;
  inset: 0;
  padding: 8px;  /* paksumpi kehys */
  border-radius: inherit;
  background: conic-gradient(
    from 0deg,
    #ff3366,
    #ff6b00,
    #06f,
    #06b6d4,
    #8b5cf6,
    #ff3366
  );
  -webkit-mask:
    linear-gradient(#000 0 0) content-box,
    linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
          mask-composite: exclude;

  pointer-events: none;
  opacity: 1;           /* kirkkaampi */
  filter: blur(0.3px);    /* hyvin pieni pehmennys */
}

@keyframes borderGlow {
  0%   { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }  /* pyörivä sateenkaari */
}


/* Vähennä animaatiota, jos käyttäjä ei halua liikettä */
@media (prefers-reduced-motion: reduce) {
  .board::before { animation: none; opacity: .6; }
}

  .cell{ width:var(--cell); height:var(--cell); background:#fff; display:grid; place-items:center;
    font-weight:700; font-size:20px; cursor:pointer; position:relative; border-radius:8px; transition:transform .06s ease; }
  .cell:active{ transform:scale(.98) }
  .cell.selected{ outline:3px solid var(--accent); z-index:2 }
  .cell.err{ color:var(--bad) } .cell.ok{ color:var(--ok) }
  .black{ background:var(--black); color:#fff; cursor:default }
  .black::before{ content:""; position:absolute; inset:0; background:linear-gradient(135deg, transparent 49%, #fff 0, #fff 51%, transparent 0);
    opacity:.18; border-radius:8px; }
  .clue{ position:absolute; font-size:11px; line-height:1; color:#e6e6e6; font-weight:800; pointer-events:none }
  .clue.across{ right:6px; top:6px } .clue.down{ left:6px; bottom:6px }

  /* PAD: 2 riviä, 6 saraketta, keskitetty */
  .pad-wrap{
    display:flex; flex-direction:column; align-items:center; gap:8px; width:100%;
  }
  .pad{
    display:grid;
    grid-template-columns: repeat(6, var(--keyW));
    grid-template-rows: repeat(2, var(--keyH));
    gap: var(--padGap);
    justify-content: center;
    align-content: center;
  }
  .key{
    height: var(--keyH);
    width: var(--keyW);
    display:grid; place-items:center; background:#fff; border:2px solid #ddd; border-radius:12px;
    font-weight:800; font-size:20px; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,.06);
    transition:transform .06s ease, border-color .12s ease;
  }
  .key:hover{ border-color:#bbb } .key:active{ transform:translateY(1px) scale(.99) }
  .key.special{ background:#fbfbff; border-color:#cdd8ff }
  .key.help{ background:#fffaf0; border-color:#ffd89e }
  .key.spacer{ visibility:hidden; pointer-events:none } /* Täyte, jotta 2 riviä säilyy */

  .btn{ background:#fff; border:2px solid #ddd; border-radius:10px; padding:8px 12px; font-weight:700; cursor:pointer }
  .btn:hover{ border-color:#bbb }
  .status{ font-size:14px; color:var(--hint); min-height:1.5em; text-align:center; width:100% }

  .ctrl{ background:#fff; border:2px solid #ddd; border-radius:10px; padding:6px 10px; font-weight:600 }
  label{ font-size:13px; color:#333 }
  select.ctrl, input[type=range].ctrl, input[type=text].ctrl{ height: 36px }
  input[type=range].ctrl{ width: 80px }
  input[type=text].ctrl{ width: 55px }
  .note{ font-size:12px; color:#884; }

  /* Setup-dialogi */
  dialog#setupDlg{
    width:min(100vw - 24px, 520px);
    border:none; border-radius:14px; padding:16px; box-shadow:0 10px 40px rgba(0,0,0,.18);
    background:#fff;
  }
  dialog#setupDlg::backdrop{ background: rgba(0,0,0,.25) }
  .dlg-actions{ display:flex; gap:10px; justify-content:flex-end; margin-top:8px }

  /* iPad/kompakti tiivistys */
  @media (max-width: 900px){
    :root{
      --cell: 42px;
      --keyW: 48px;
      --keyH: 48px;
      --padGap: 6px;
    }
    body{ padding:12px }
    .wrap{ width: min(100vw - 16px, 430px) }
    .cell{ font-size:18px; border-radius:8px }
    .btn{ padding:6px 10px; font-size:14px }
    select.ctrl, input[type=range].ctrl, input[type=text].ctrl{ height:32px }
  }
    .dialog-footer {
    display: flex;
    justify-content: space-between; /* OHJE vasemmalle, Aloita peli oikealle */
    align-items: center;
    margin-top: 1em;
  }

  /* OHJE-linkin tyyli */
  .ohje-linkki {
    display: inline-block;      /* jotta padding toimii paremmin */
    padding: 8px 16px;
    background-color: #0F172A;  /* tummansininen tausta */
    color: white;               /* valkoinen teksti */
    text-decoration: none;      /* poistaa alleviivauksen */
    border-radius: 8px;         /* pyöristetyt kulmat */
    font-weight: bold;
  }

  .ohje-linkki:hover {
    background-color: #1e293b;  /* vaaleampi hover-efekti */
  }
  /* Aloita peli -nappi pysyy omassa tyylissään */
  
  #startBtn {
    padding: 8px 16px;
    font-size: 1rem;
    border-radius: 8px;

    background-color: #0F172A;
    color: white;
	font-weight: bold;
    cursor: pointer;
  }
  #startBtn:hover {
    background-color: #1e293b;
  }
.loader {
  border: 6px solid #f3f3f3;
  border-top: 6px solid #f59e0b; /* oranssi teema */
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: 0 auto 10px auto;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
} 



</style>
</head>
<body>

  <!-- ASETUKSET + OHJEET DIALOGISSA -->
  <dialog id="setupDlg">
    <h1>Kakuro – Classic & Latin-first</h1>
    <div class="row" style="margin-bottom:6px;">
      <label>Tapa:</label>
      <select id="mode" class="ctrl">
        <option value="classic">Classic</option>
        <option value="latin">45 rivi/sarake</option>
      </select>

      <label>Ruudukon koko:</label>
      <select id="size" class="ctrl">
        <option>8</option><option selected>10</option><option>12</option><option>14</option>
      </select>
    </div>

    <div class="row" style="margin-bottom:6px;">
      <label>Min run:</label>
      <input id="minRun" class="ctrl" type="range" min="2" max="6" value="2" />
      <span id="minRunVal" class="ctrl" style="padding:4px 8px;">2</span>

      <label>Max run:</label>
      <input id="maxRun" class="ctrl" type="range" min="3" max="9" value="6" />
      <span id="maxRunVal" class="ctrl" style="padding:4px 8px;">6</span>
    </div>

    <div class="row" style="margin-bottom:6px;">
      <label>Mustien osuus (%):</label>
      <input id="pct" class="ctrl" type="range" min="10" max="50" value="30" />
      <span id="pctVal" class="ctrl" style="padding:4px 8px;">30%</span>

      <label>Siemen:</label>
      <input id="seed" class="ctrl" type="text" placeholder="opt." />
    </div>

    <div class="row" style="margin-bottom:6px;">
      <label style="display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="unique" />
        Vaadi yksikäsitteinen (Classic)
      </label>
      <label style="display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="showOk" checked />
        Korosta oikeat (vihreä)
      </label>
    </div>

    <div class="note" id="latinNote" style="display:none; margin-top:-2px;">
      Latin-first toimii vain kun sisäalue on 9×9 → valitse ruudukon koko 10×10.
    </div>
 <div class="dialog-footer">
  <a href="./ohje.html" class="ohje-linkki">Ohje</a>
  <button id="startBtn">Aloita peli</button>
</div>

  </dialog>

  <!-- VARSINAINEN PELINÄYTTÖ -->
  <div class="wrap">
    <div class="row" style="justify-content:space-between">

        <button class="btn" id="newBtn">Uusi ruudukko</button>
        <button class="btn" id="showBtn">Näytä ratkaisu</button>
        <button class="btn" id="checkBtn">Tarkista</button>
        <button class="btn" id="resetBtn">Tyhjennä</button>

    </div>

    <div class="board" id="board" aria-label="Kakuro-ruudukko"></div>

    <div class="pad-wrap">
      <div class="pad" id="pad" aria-label="Numeronäppäimistö"></div>
      <span class="status" id="status">Valitse ruutu aloittaaksesi.</span>
    </div>
  </div>
<div id="spinner" style="display:none;
     position:fixed; top:50%; left:50%;
     transform:translate(-50%,-50%);
     background:rgba(0,0,0,0.6);
     color:white; padding:20px 30px;
     border-radius:8px; font-size:1.1rem;
     z-index:2000; text-align:center;">
  <div class="loader"></div>
  <div>Tarkistetaan yksikäsitteisyyttä…</div>
</div>
<script>
/* ======================= ASETUKSET ======================= */
let N = 10; // kokonaiskoko (sis. kehyksen)
let MIN_RUN = 2;
let MAX_RUN = 6;
let SHOW_OK = true; // UUSI: vihreä korostus päällä/pois
const MAX_NODE_VISITS = 120000;  // classic-solver
const MAX_MASK_TRIES = 400;
const UNIQUE_NODE_CAP = 250000;  // uniqueness-solverin varoraja
/* ========================================================= */

const setupDlg = document.getElementById('setupDlg');
const startBtn = document.getElementById('startBtn');

const boardEl = document.getElementById('board');
const padEl = document.getElementById('pad');
const statusEl = document.getElementById('status');
const newBtn = document.getElementById('newBtn');
const showBtn = document.getElementById('showBtn');
const checkBtn = document.getElementById('checkBtn');
const resetBtn = document.getElementById('resetBtn');
const modeSel = document.getElementById('mode');
const sizeSel = document.getElementById('size');
const minRun = document.getElementById('minRun');
const maxRun = document.getElementById('maxRun');
const minRunVal = document.getElementById('minRunVal');
const maxRunVal = document.getElementById('maxRunVal');
const pct = document.getElementById('pct');
const pctVal = document.getElementById('pctVal');
const seedInput = document.getElementById('seed');
const latinNote = document.getElementById('latinNote');
const uniqueChk = document.getElementById('unique');
const showOkChk = document.getElementById('showOk');

/* ---------- UI apurit: synkronoinnit ---------- */
function syncControlsFromState(){
  sizeSel.value = String(N);
  minRun.value = String(MIN_RUN);
  maxRun.value = String(MAX_RUN);
  minRunVal.textContent = String(MIN_RUN);
  maxRunVal.textContent = String(MAX_RUN);
  pctVal.textContent = pct.value + '%';
  showOkChk.checked = !!SHOW_OK;
  updateLatinAvailability();
}
function syncStateFromControls(){
  N = parseInt(sizeSel.value,10);
  MIN_RUN = parseInt(minRun.value,10);
  MAX_RUN = parseInt(maxRun.value,10);
  if (MAX_RUN < MIN_RUN+1){ MAX_RUN = MIN_RUN+1; maxRun.value = String(MAX_RUN); }
  SHOW_OK = !!showOkChk.checked; // UUSI
}

/* ---------- Säätimien eventit ---------- */
minRun.addEventListener('input', ()=>{ 
  MIN_RUN = parseInt(minRun.value,10); 
  if (MAX_RUN < MIN_RUN+1){ MAX_RUN = MIN_RUN+1; maxRun.value = String(MAX_RUN); }
  minRunVal.textContent = String(MIN_RUN);
  maxRunVal.textContent = String(MAX_RUN);
});
maxRun.addEventListener('input', ()=>{ 
  MAX_RUN = parseInt(maxRun.value,10); 
  if (MAX_RUN < MIN_RUN+1){ MIN_RUN = Math.max(2, MAX_RUN-1); minRun.value = String(MIN_RUN); }
  minRunVal.textContent = String(MIN_RUN);
  maxRunVal.textContent = String(MAX_RUN);
});
pct.addEventListener('input', ()=>{ pctVal.textContent = pct.value + '%'; });

sizeSel.addEventListener('change', ()=>{
  N = parseInt(sizeSel.value,10);
  updateLatinAvailability();
});
modeSel.addEventListener('change', updateLatinAvailability);

function updateLatinAvailability(){
  const inner = N-1;
  const latinAllowed = (inner === 9);
  latinNote.style.display = (modeSel.value==='latin' && !latinAllowed) ? 'block' : 'none';
  if(!latinAllowed && modeSel.value==='latin'){
    modeSel.value = 'classic';
  }
}

/* ---------- Pelitila ---------- */
let MASK=null, SOL=null, CLUES=null, values=null, selected=null;

/* ---------- Siemennetty satunnaisuus (mulberry32) ---------- */
function mulberry32(a) {
  return function() {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
function seededRandomSetup(seedStr){
  if(!seedStr) return; // käytä normaalia Math.randomia
  let h=0;
  for(let i=0;i<seedStr.length;i++) h = Math.imul(31, h) + seedStr.charCodeAt(i) | 0;
  const rng = mulberry32(h>>>0);
  Math.random = rng; // huom! override tämän istunnon ajaksi
}

/* ---------- Pienet apurit ---------- */
const randInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const shuffle=(arr)=>{for(let i=arr.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[arr[i],arr[j]]=[arr[j],arr[i]];}return arr;};
const DIRS=[[1,0],[-1,0],[0,1],[0,-1]];
const inB=(r,c)=>r>=0&&r<N&&c>=0&&c<N;

function whiteConnectedSize(mask){
  const whites=[]; for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(mask[r][c]===1) whites.push([r,c]);
  if(!whites.length) return 0;
  const seen=Array.from({length:N},()=>Array(N).fill(false));
  const q=[whites[0]]; seen[whites[0][0]][whites[0][1]]=true;
  let cnt=0;
  while(q.length){
    const [r,c]=q.shift(); cnt++;
    for(const [dr,dc] of DIRS){
      const nr=r+dr,nc=c+dc;
      if(inB(nr,nc)&&!seen[nr][nc]&&mask[nr][nc]===1){ seen[nr][nc]=true; q.push([nr,nc]); }
    }
  }
  return cnt;
}
const countWhites = mask => mask.flat().filter(x=>x===1).length;

/* ---------- Rivit/juoksut ---------- */
function listRuns(mask) {
  const runs = { across: [], down: [] };
  // across
  for (let r = 0; r < N; r++) {
    let s = 0;
    while (s < N) {
      while (s < N && mask[r][s] === 0) s++;
      if (s >= N) break;
      let e = s;
      while (e + 1 < N && mask[r][e + 1] === 1) e++;
      runs.across.push({ r, s, e, len: e - s + 1 });
      s = e + 1;
    }
  }
  // down
  for (let c = 0; c < N; c++) {
    let s = 0;
    while (s < N) {
      while (s < N && mask[s][c] === 0) s++;
      if (s >= N) break;
      let e = s;
      while (e + 1 < N && mask[e + 1][c] === 1) e++;
      runs.down.push({ c, s, e, len: e - s + 1 });
      s = e + 1;
    }
  }
  return runs;
}
function createsOneRun(mask, r, c) {
  // across
  let L = c - 1; while (L >= 0 && mask[r][L] === 1) L--;
  let R = c + 1; while (R < N && mask[r][R] === 1) R++;
  const leftLen  = c - 1 - L;
  const rightLen = R - (c + 1);
  if ((leftLen === 1 && mask[r][c - 1] === 1) || (rightLen === 1 && mask[r][c + 1] === 1)) return true;
  // down
  let U = r - 1; while (U >= 0 && mask[U][c] === 1) U--;
  let D = r + 1; while (D < N && mask[D][c] === 1) D++;
  const upLen   = r - 1 - U;
  const downLen = D - (r + 1);
  if ((upLen === 1 && mask[r - 1][c] === 1) || (downLen === 1 && mask[r + 1][c] === 1)) return true;
  return false;
}
function tryCut(mask, r, c){
  const prevWhites = countWhites(mask);
  const old = mask[r][c];
  mask[r][c] = 0;
  const ok = !createsOneRun(mask, r, c) && whiteConnectedSize(mask) === prevWhites - 1;
  if(!ok) mask[r][c] = old;
  return ok;
}
function capLongRuns(mask) {
  let changed = true, safety = 0;
  while (changed && safety++ < 200) {
    changed = false;
    // across
    const runsA = listRuns(mask).across;
    for (const run of runsA) {
      if (run.len <= MAX_RUN) continue;
      const candidates = [];
      for(let pos=run.s+MIN_RUN; pos<=run.e-MIN_RUN; pos++) candidates.push(pos);
      shuffle(candidates);
      let cutMade=false;
      for(const pos of candidates){
        if(tryCut(mask, run.r, pos)){ cutMade=true; changed=true; break; }
      }
      if(cutMade) break;
    }
    if(changed) continue;
    // down
    const runsD = listRuns(mask).down;
    for (const run of runsD) {
      if (run.len <= MAX_RUN) continue;
      const candidates = [];
      for(let pos=run.s+MIN_RUN; pos<=run.e-MIN_RUN; pos++) candidates.push(pos);
      shuffle(candidates);
      let cutMade=false;
      for(const pos of candidates){
        if(tryCut(mask, pos, run.c)){ cutMade=true; changed=true; break; }
      }
      if(cutMade) break;
    }
  }
}

/* ---------- Latin-first ratkaisuruudukko (vain sisäalue 9×9) ---------- */
function latinSolution(){
  const grid = Array.from({length:N},()=>Array(N).fill(0));
  const perm = a => shuffle(a.slice());
  const rowP = perm([...Array(9)].map((_,i)=>i));
  const colP = perm([...Array(9)].map((_,i)=>i));
  const valP = perm([1,2,3,4,5,6,7,8,9]);
  for(let rr=0; rr<9; rr++){
    for(let cc=0; cc<9; cc++){
      const base = 1 + ((rr + cc) % 9);
      const v = valP[base-1];
      const r = rowP[rr] + 1;
      const c = colP[cc] + 1;
      grid[r][c] = v;
    }
  }
  return grid;
}

/* ---------- Classic: backtracking-täyttö ---------- */
function getAcrossRun(mask,r,c){
  if(mask[r][c]===0) return [];
  let s=c; while(s>0 && mask[r][s-1]===1) s--;
  let e=c; while(e+1<N && mask[r][e+1]===1) e++;
  const out=[]; for(let x=s;x<=e;x++) out.push([r,x]); return out;
}
function getDownRun(mask,r,c){
  if(mask[r][c]===0) return [];
  let s=r; while(s>0 && mask[s-1][c]===1) s--;
  let e=r; while(e+1<N && mask[e+1][c]===1) e++;
  const out=[]; for(let y=s;y<=e;y++) out.push([y,c]); return out;
}
function fillSolutionClassic(mask){
  const whites=[]; for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(mask[r][c]===1) whites.push([r,c]);
  const acrossMap=new Map(), downMap=new Map();
  for(const [r,c] of whites){
    acrossMap.set(r+","+c, getAcrossRun(mask,r,c));
    downMap.set(r+","+c, getDownRun(mask,r,c));
  }
  const sol=Array.from({length:N},()=>Array(N).fill(0));
  let nodeVisits=0;
  function candAt(r,c){
    const a=acrossMap.get(r+","+c), d=downMap.get(r+","+c);
    const usedA=new Set(a.map(([rr,cc])=>sol[rr][cc]).filter(v=>v>0));
    const usedD=new Set(d.map(([rr,cc])=>sol[rr][cc]).filter(v=>v>0));
    const order = Math.random()<0.5 ? [...Array(9)].map((_,i)=>i+1) : shuffle([...Array(9)].map((_,i)=>i+1));
    const out=[]; for(const v of order){ if(!usedA.has(v)&&!usedD.has(v)) out.push(v); }
    return out;
  }
  function nextCell(){
    let best=null, score=1e9;
    for(const [r,c] of whites){
      if(sol[r][c]!==0) continue;
      const aLen=acrossMap.get(r+","+c).length;
      const dLen=downMap.get(r+","+c).length;
      const cands=candAt(r,c);
      if(cands.length===0) return [r,c,cands];
      const s=cands.length*10+(aLen+dLen);
      if(s<score){ score=s; best=[r,c,cands]; if(cands.length===1) break; }
    }
    return best;
  }
  function backtrack(){
    if(++nodeVisits>MAX_NODE_VISITS) return false;
    const pick=nextCell();
    if(!pick) return true;
    const [r,c,cands]=pick;
    for(const v of cands){
      sol[r][c]=v;
      if(backtrack()) return true;
      sol[r][c]=0;
      if(nodeVisits>MAX_NODE_VISITS) return false;
    }
    return false;
  }
  if(!backtrack()) return null;
  return sol;
}

/* ---------- Vihjeet ---------- */
function computeClues(mask, sol){
  const clues=Array.from({length:N},()=>Array(N).fill(null));
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      if(mask[r][c]===0){
        let A=null,D=null;
        if(c+1<N && mask[r][c+1]===1){
          let s=0,cc=c+1; while(cc<N && mask[r][cc]===1){ s+=sol[r][cc]; cc++; }
          if(cc>c+1) A=s;
        }
        if(r+1<N && mask[r+1][c] === 1){
          let s=0,rr=r+1; while(rr<N && mask[rr][c]===1){ s+=sol[rr][c]; rr++; }
          if(rr>r+1) D=s;
        }
        if(A!==null || D!==null) clues[r][c]={A,D};
      }
    }
  }
  return clues;
}

/* ---------- Maskin generointi ---------- */
function makeMaskAttempt(targetTotal){
  const m = Array.from({length:N},(_,r)=>Array.from({length:N},(_,c)=>(r===0||c===0)?0:1));
  let blacks = 2*N - 1;
  const inner=[]; for(let r=1;r<N;r++) for(let c=1;c<N;c++) inner.push([r,c]);
  shuffle(inner);
  for(const [r,c] of inner){
    if(blacks>=targetTotal) break;
    if(m[r][c]===0) continue;
    const prevWhites = countWhites(m);
    m[r][c]=0;
    if (createsOneRun(m, r, c) || whiteConnectedSize(m)!==prevWhites-1){
      m[r][c]=1;
    }else{
      blacks++;
    }
  }
  capLongRuns(m);
  return m;
}
function generateMaskByPct(pctInner){
  const base = 2*N - 1;
  const innerCells = (N-1)*(N-1);
  const add = Math.round(innerCells * (pctInner/100));
  const targetTotal = Math.min(base + add, N*N-1);
  for(let tries=0; tries<MAX_MASK_TRIES; tries++){
    const m = makeMaskAttempt(targetTotal);
    const runs = listRuns(m);
    const allOk = runs.across.every(r=>r.len>=MIN_RUN && r.len<=MAX_RUN)
                && runs.down.every(r=>r.len>=MIN_RUN && r.len<=MAX_RUN);
    const whites = countWhites(m);
    if(allOk && whiteConnectedSize(m)===whites) return m;
  }
  return makeMaskAttempt(targetTotal);
}

/* ---------- Uniqueness ---------- */
function buildRunsFromClues(mask, clues){
  const whites=[];
  for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(mask[r][c]===1) whites.push([r,c]);
  const aRuns=[], dRuns=[];
  const aIndex = Array.from({length:N},()=>Array(N).fill(-1));
  const dIndex = Array.from({length:N},()=>Array(N).fill(-1));
  // across
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      if(mask[r][c]===0 && clues[r][c] && clues[r][c].A!=null){
        const sum = clues[r][c].A;
        const cells=[];
        let cc=c+1;
        while(cc<N && mask[r][cc]===1){ cells.push([r,cc]); cc++; }
        const idx=aRuns.length;
        aRuns.push({sum, cells});
        for(const [rr,cc2] of cells) aIndex[rr][cc2]=idx;
      }
    }
  }
  // down
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      if(mask[r][c]===0 && clues[r][c] && clues[r][c].D!=null){
        const sum = clues[r][c].D;
        const cells=[];
        let rr=r+1;
        while(rr<N && mask[rr][c]===1){ cells.push([rr,c]); rr++; }
        const idx=dRuns.length;
        dRuns.push({sum, cells});
        for(const [rr2,cc] of cells) dIndex[rr2][cc]=idx;
      }
    }
  }
  return {whites, aRuns, dRuns, aIndex, dIndex};
}
function countSolutions(mask, clues, limit=2){
  const {whites, aRuns, dRuns, aIndex, dIndex} = buildRunsFromClues(mask, clues);
  const W = whites.length;
  const aUsed = aRuns.map(()=>0);
  const dUsed = dRuns.map(()=>0);
  const aSum = aRuns.map(()=>0);
  const dSum = dRuns.map(()=>0);
  const aRem = aRuns.map((_,i)=>aRuns[i].cells.length);
  const dRem = dRuns.map((_,i)=>dRuns[i].cells.length);
  const assign = Array(W).fill(0);

  function minMaxPossible(maskAvail, k){
    const avail=[];
    for(let d=1; d<=9; d++) if(!(maskAvail & (1<<d))) avail.push(d);
    if(avail.length < k) return [Infinity, -Infinity];
    avail.sort((a,b)=>a-b);
    let mn=0; for(let i=0;i<k;i++) mn+=avail[i];
    let mx=0; for(let i=0;i<k;i++) mx+=avail[avail.length-1-i];
    return [mn, mx];
  }
  function candidatesForCell(r,c){
    const ai = aIndex[r][c]; const di = dIndex[r][c];
    const usedA = aUsed[ai], usedD = dUsed[di];
    const sumA = aSum[ai], sumD = dSum[di];
    const remA = aRem[ai], remD = dRem[di];
    const targetA = aRuns[ai].sum, targetD = dRuns[di].sum;
    const out=[];
    for(let v=1; v<=9; v++){
      const bit = 1<<v;
      if(usedA & bit) continue;
      if(usedD & bit) continue;
      const newSumA = sumA + v, newRemA = remA - 1, needA = targetA - newSumA;
      const newSumD = sumD + v, newRemD = remD - 1, needD = targetD - newSumD;
      if(needA < 0 || needD < 0) continue;
      const [minA,maxA] = minMaxPossible(usedA | bit, newRemA);
      const [minD,maxD] = minMaxPossible(usedD | bit, newRemD);
      if(newRemA>0 && (needA < minA || needA > maxA)) continue;
      if(newRemD>0 && (needD < minD || needD > maxD)) continue;
      if(newRemA===0 && needA!==0) continue;
      if(newRemD===0 && needD!==0) continue;
      out.push(v);
    }
    return out;
  }
  function pickCell(){
    let bestIdx=-1, bestCands=null, bestLen=1e9;
    for(let i=0;i<W;i++){
      if(assign[i]!==0) continue;
      const [r,c]=whites[i];
      const cands=candidatesForCell(r,c);
      const len=cands.length;
      if(len===0) return [i, cands];
      if(len<bestLen){ bestLen=len; bestIdx=i; bestCands=cands; if(len===1) break; }
    }
    return [bestIdx, bestCands];
  }
  let node=0, solutions=0;
  function dfs(){
    if(solutions>=limit) return;
    if(++node>UNIQUE_NODE_CAP) return;
    let done=true;
    for(let i=0;i<W;i++){ if(assign[i]===0){ done=false; break; } }
    if(done){ solutions++; return; }
    const [i, cands] = pickCell();
    if(i<0) return;
    const [r,c] = whites[i];
    const ai = aIndex[r][c], di = dIndex[r][c];
    for(const v of cands){
      const bit=1<<v;
      assign[i]=v;
      aUsed[ai]|=bit; aSum[ai]+=v; aRem[ai]--;
      dUsed[di]|=bit; dSum[di]+=v; dRem[di]--;
      dfs();
      dRem[di]++; dSum[di]-=v; dUsed[di]&=~bit;
      aRem[ai]++; aSum[ai]-=v; aUsed[ai]&=~bit;
      assign[i]=0;
      if(solutions>=limit || node>UNIQUE_NODE_CAP) return;
    }
  }
  dfs();
  return {count: solutions, capped: (node>UNIQUE_NODE_CAP)};
}

/* ---------- UI ---------- */
function setBoardGrid(){
  boardEl.style.gridTemplateColumns = `repeat(${N}, var(--cell))`;
  boardEl.style.gridTemplateRows = `repeat(${N}, var(--cell))`;
}
function buildBoard(){
  setBoardGrid();
  boardEl.innerHTML="";
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const div=document.createElement('div');
      if(MASK[r][c]===0){
        div.className='cell black';
        const clue=CLUES[r][c];
        if(clue){
          if(clue.A!=null){ const d=document.createElement('div'); d.className='clue across'; d.textContent=clue.A; div.appendChild(d); }
          if(clue.D!=null){ const d=document.createElement('div'); d.className='clue down'; d.textContent=clue.D; div.appendChild(d); }
        }
      }else{
        div.className='cell white';
        div.dataset.r=r; div.dataset.c=c;
        div.addEventListener('click', ()=>selectCell(r,c));
        div.textContent=values[r][c];
      }
      boardEl.appendChild(div);
    }
  }
}
function refreshCells(){
  const kids=[...boardEl.children];
  for(let i=0;i<kids.length;i++){
    const r=(i/ N)|0, c=i%N;
    const el=kids[i];
    if(MASK[r][c]===1){
      el.textContent=values[r][c];
      el.classList.toggle('selected', !!selected && selected[0]===r && selected[1]===c);
      const st=checkCell(r,c);
      el.classList.toggle('err', st==='err');
      el.classList.toggle('ok',  SHOW_OK && st==='ok'); // UUSI: vihreä vain, jos sallittu
    }
  }
}
function selectCell(r,c){
  selected=[r,c];
  statusEl.textContent=`Valittu ruutu: rivi ${r+1}, sarake ${c+1}`;
  refreshCells();
}

/* --- PAD: 1–9, x, ?, + 1 spacer, jotta 2 riviä säilyy --- */
const KEYS=['1','2','3','4','5','6','7','8','9','x','?']; // 11 kpl
function buildPad(){
  padEl.innerHTML="";
  const order = [...KEYS, '_spacer_']; // 12 paikkaa (6x2)
  for(const k of order){
    const b=document.createElement('button');
    if(k==='_spacer_'){
      b.className='key spacer';
      padEl.appendChild(b);
      continue;
    }
    b.className='key';
    if(k==='x') b.classList.add('special');
    if(k==='?') b.classList.add('help');
    b.textContent=k;
    b.addEventListener('click', ()=>pressKey(k));
    padEl.appendChild(b);
  }
}

function pressKey(k){
  if(!selected){ statusEl.textContent='Valitse ensin ruutu.'; return; }
  const [r,c]=selected;
  if(MASK[r][c]===0){ statusEl.textContent='Valitse valkoinen ruutu.'; return; }
  if(k==='x'){ values[r][c]=""; }
  else if(k==='?'){ values[r][c]=String(SOL[r][c]); }
  else { values[r][c]=k; }
  refreshCells();
}
function checkCell(r,c){
  if(MASK[r][c]===0) return null;
  const v=values[r][c]; if(!v) return null;

  const aRun=getAcrossRun(MASK,r,c);
  let left=aRun[0][1]-1;
  let A=(left>=0 && CLUES[r][left]) ? CLUES[r][left].A : null;
  const aVals=aRun.map(([rr,cc])=>values[rr][cc]).filter(x=>x!=="").map(Number);
  const aDup=(new Set(aVals)).size!==aVals.length;
  const aSum=aVals.reduce((a,b)=>a+b,0);
  if(aDup || (A!==null && aSum>A)) return 'err';
  if(A!==null && aVals.length===aRun.length && aSum===A){
    const allMatch=aRun.every(([rr,cc])=>String(SOL[rr][cc])===values[rr][cc]);
    if(allMatch) return 'ok';
  }

  const dRun=getDownRun(MASK,r,c);
  let up=dRun[0][0]-1;
  let D=(up>=0 && CLUES[up][c]) ? CLUES[up][c].D : null;
  const dVals=dRun.map(([rr,cc])=>values[rr][cc]).filter(x=>x!=="").map(Number);
  const dDup=(new Set(dVals)).size!==dVals.length;
  const dSum=dVals.reduce((a,b)=>a+b,0);
  if(dDup || (D!==null && dSum>D)) return 'err';
  if(D!==null && dVals.length===dRun.length && dSum===D){
    const allMatch=dRun.every(([rr,cc])=>String(SOL[rr][cc])===values[rr][cc]);
    if(allMatch) return 'ok';
  }
  return null;
}

/* ---------- Komennot ---------- */
checkBtn.addEventListener('click', ()=>{
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    if(MASK[r][c]===1){
      if(String(SOL[r][c])!==values[r][c]){
        statusEl.textContent='Ei vielä oikein. Vihje: ? paljastaa valitun ruudun.';
        refreshCells(); return;
      }
    }
  }
  statusEl.textContent='Täysin oikein! ✅';
  refreshCells();
});
resetBtn.addEventListener('click', ()=>{
  values=Array.from({length:N},()=>Array(N).fill(""));
  selected=null;
  statusEl.textContent='Kaikki merkinnät tyhjennetty.';
  refreshCells();
});

/* --- Uusi ruudukko avaa dialogin --- */
newBtn.addEventListener('click', ()=>{
  syncControlsFromState();  // näytä nykyiset asetukset
  setupDlg.showModal();
});
showBtn.addEventListener('click', ()=>{
  for(let r=0;r<N;r++) for(let c=0;c<N;c++){
    if(MASK[r][c]===1) values[r][c]=String(SOL[r][c]);
  }
  statusEl.textContent='Ratkaisu näytetty.';
  refreshCells();
});

function showSpinner() {
  document.getElementById("spinner").style.display = "block";
}
function hideSpinner() {
  document.getElementById("spinner").style.display = "none";
}
/* ---------- Uuden pulman teko ---------- */
function newPuzzle(){
  // siemen
  seededRandomSetup(seedInput.value.trim());

  // asetukset
  syncStateFromControls();
  updateLatinAvailability();
  setBoardGrid();

  statusEl.textContent='Luodaan uutta ruudukkoa…';

  // Näytä spinner ennen raskasta vaihetta
  showSpinner();

  setTimeout(() => {
    // 1) Ratkaisuruudukko
    if(modeSel.value==='latin'){
      if(N!==10){ modeSel.value='classic'; }
    }
    if(modeSel.value==='latin'){
      SOL = latinSolution();
    }

    // 2) Maski
    MASK = generateMaskByPct(parseInt(pct.value,10));

    // 3) Classic
    let attempts = 0;
    if(modeSel.value==='classic'){
      while(true){
        SOL = fillSolutionClassic(MASK);
        if(!SOL){
          if(++attempts>8){
            MASK = generateMaskByPct(parseInt(pct.value,10));
            attempts=0;
          } else {
            continue;
          }
        } else {
          CLUES = computeClues(MASK, SOL);
          if(uniqueChk.checked){
            const res = countSolutions(MASK, CLUES, 2);
            if(res.capped){
              statusEl.textContent='Uniikkitarkistus keskeytettiin (liian raskas). Luo uudelleen tai löysää asetuksia.';
              break;
            }
            if(res.count===1){
              break;
            } else {
              if(++attempts>10){
                MASK = generateMaskByPct(parseInt(pct.value,10));
                attempts=0;
              }
              SOL = null;
              continue;
            }
          } else {
            break;
          }
        }
      }
    } else {
      CLUES = computeClues(MASK, SOL);
    }

    // 4) Pelaajalle tyhjä taulu
    values = Array.from({length:N},()=>Array(N).fill(""));
    selected=null;
    buildBoard();
    refreshCells();
    statusEl.textContent='Uusi ruudukko valmis. Valitse ruutu ja syötä numero.';

    // Piilota spinner
    hideSpinner();
  }, 50); // pieni viive, jotta spinner ehtii näkyä
}


/* ---------- Alustus ---------- */
(function init(){
  buildPad();
  setBoardGrid();
  updateLatinAvailability();
  // Avataan dialogi alkuun:
  syncControlsFromState();
  setupDlg.showModal();
})();
startBtn.addEventListener('click', ()=>{
  setupDlg.close();
  newPuzzle();
});
</script>
 <footer style="
  position: fixed;
  bottom: 4px;
  right: 6px;
  font-size: 14px;
  color: black;
  padding: 4px;
  z-index: 9999;
">
  Versio 1.0.4
</footer>
</body>
</html>
